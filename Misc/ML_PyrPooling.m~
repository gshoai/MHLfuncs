classdef ML_PyrPooling
% Multi-dimensional Pyramid pooling
% Special cases: spatial pyramid, temporal pyramid, spatio-temporal pyramid pooling
% By: Minh Hoai Nguyen (minhhoai@cs.stonybrook.edu)
% Created: 14-Jul-2015
% Last modified: 14-Jul-2015    
    
    methods (Static)        
        % FeatLocs: k*n matrix, each column is a k-dim location vector.
        %   k could be any positive number, special cases are: 
        %       k = 1, temporal pooling
        %       k = 2, sptial pooling
        %       k = 3, spatio-temporal pooling        
        % FeatVecs: d*n matrix, each column is a feature vector
        % poolArea: k*2 matrix, pool(i,:) is the [min,max] of the pooling area for dimension i.
        % poolMethod: either 'mean', 'max', 'sum', 'min'
        % levelWs: nLevel*1 weight vector. Compute a pyramid of nLevel. 
        %   default: ones(nLevel,1);
        % emptyPolicy: {'inf', '-inf', 'zero', 'error'}
        %   What to do when there is a cell in the pyramid has no feature points inside
        %   error: output error
        %   zero: return a zero vector
        %   inf, -inf: return a inf/-inf vector
        % Outputs:
        %   poolVec: d*1 vector for the pooled feature or [] if there is no features in the poolArea
        %   nFeatInArea: number of features in the area
        function [poolVec, nFeatInArea] = pyrPool(FeatLocs, FeatVecs, poolArea, poolMethod, levelWs, emptyPolicy)
            nLevel = length(levelWs);
            k = size(FeatLocs, 1);
            d = size(FeatVecs, 1);

            % base case
            if nLevel == 1                
                [poolVec, nFeatInArea] = ...
                    ML_PyrPooling.pool(FeatLocs, FeatVecs, poolArea, poolMethod);
                poolVec = poolVec*levelWs(1);
                if isempty(poolVec)
                    if strcmpi(emptyPolicy, 'zero') 
                        poolVec = zeros(d, 1);
                    elseif strcmpi(emptyPolicy, 'inf') 
                        poolVec = inf(d, 1);
                    elseif strcmpi(emptyPolicy, '-inf') 
                        poolVec = -inf(d, 1);
                    else
                        error('a pooling area is empty');
                    end                        
                end                    
                return;
            end
            
            % compute recursively
            midPnts = mean(poolArea,2);            
            poolAreas = [poolArea(:,1), midPnts, midPnts + eps, poolArea(:,2)];
            
            poolVecs = cell(1, 2^k);
            nF = zeros(1, 2^k);
            for i=1:2^k  
                divIdxs = zeros( 1, k);
                for j=1:k
                    divIdxs(j) = bitget(i,j);                    
                end                
                
                minAreaIdxs = sub2ind([k, 4], 1:k, 2*divIdxs + 1);
                maxAreaIdxs = sub2ind([k, 4], 1:k, 2*divIdxs + 2);
                poolArea_i = [poolAreas(minAreaIdxs)', poolAreas(maxAreaIdxs)'];
                
                [poolVecs{i}, nF(i)] = ML_PyrPooling.pyrPool(FeatLocs, FeatVecs, poolArea_i, poolMethod, levelWs(2:end));                
            end;
                        
            poolVecs = cat(2, poolVecs{:});
            nFeatInArea = sum(nF);
            if strcmpi(poolMethod, 'sum')
                poolVec_top = sum(poolVecs(1:d,:), 2);
            elseif strcmpi(poolMethod, 'max')
                poolVec_top = max(poolVecs(1:d,:), [], 2);
            elseif strcmpi(poolMethod, 'min')
                poolVec_top = min(poolVecs(1:d,:), [], 2);
            elseif strcmpi(poolMethod, 'mean')
                poolVec_top = sum(poolVecs(1:d,:).*repmat(nF, d, 1), 2)/nFeatInArea;
            else
                error('ML_PyrPooling.pyrPool: Unkown pooling option');
            end;
            poolVec_top = levelWs(1)/levelWs(2)*poolVec_top;                        
            poolVec = cat(1, poolVec_top, poolVecs(:));            
        end
        
        % FeatLocs: k*n matrix, each column is a k-dim location vector.
        %   k could be any positive number, special cases are: 
        %       k = 1, temporal pooling
        %       k = 2, sptial pooling
        %       k = 3, spatio-temporal pooling        
        % FeatVecs: d*n matrix, each column is a feature vector
        % poolArea: k*2 matrix, pool(i,:) is the [min,max] of the pooling area for dimension i.
        % poolMethod: either 'mean', 'max', 'sum', 'min'
        % Outputs:
        %   poolVec: d*1 vector for the pooled feature or [] if there is no features in the poolArea
        %   nFeatInArea: number of features in the area
        function [poolVec, nFeatInArea] = pool(FeatLocs, FeatVecs, poolArea, poolMethod)
            n = size(FeatLocs, 2);
            A = cat(1, FeatLocs >=  repmat(poolArea(:,1), 1, n), ...
                       FeatLocs <=  repmat(poolArea(:,1), 1, n));
            inPoolAreaIdxs  = all(A,1); % indexes of features in the pool area
            nFeatInArea = sum(inPoolAreaIdxs);
            if nFeatInArea > 0
                if strcmpi(poolMethod, 'mean')
                    poolVec = mean(FeatVecs(:,inPoolAreaIdxs), 2);
                elseif strcmpi(poolMethod, 'max')
                    poolVec = max(FeatVecs(:,inPoolAreaIdxs), [], 2);
                elseif strcmpi(poolMethod, 'min')
                    poolVec = min(FeatVecs(:,inPoolAreaIdxs), [], 2); 
                elseif strcmpi(poolMethod, 'sum')
                    poolVec = sum(FeatVecs(:,inPoolAreaIdxs), 2);
                else
                    error('ML_PyrPooling.pool: Unkown pooling option');
                end
            else
                poolVec = [];
            end;
        end                   
    end    
    
    methods 
        function test1(self)
            imH = 20;
            imW = 30;
            nBin = 10;
            im = randi(nBin, [imH, imH]); % a random assignment of pixels to histogram bin
            [X, Y] = meshgrid(1:imW, 1:imH);
            FeatVecs = zeros(nBin, numel(im));
            FeatVecs(im(:)) = 1;
            FeatLocs = [X(:)'; Y(:)'];
            ML_PyrPooling.pool(FeatLocs, 
        
        end;        
    end
end

